/*
 * MCP Prompt for identifying vulnerabilities.
 */
package ghidrassistmcp.prompts;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileResults;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.util.task.TaskMonitor;
import io.modelcontextprotocol.spec.McpSchema;

/**
 * Prompt for identifying potential security vulnerabilities in a function.
 */
public class IdentifyVulnerabilityPrompt implements McpPrompt {

    @Override
    public String getName() {
        return "identify_vulnerability";
    }

    @Override
    public String getDescription() {
        return "Analyze a function for potential security vulnerabilities (buffer overflows, format strings, etc.)";
    }

    @Override
    public List<McpSchema.PromptArgument> getArguments() {
        return List.of(
            new McpSchema.PromptArgument(
                "function_name",
                "Name or address of the function to analyze for vulnerabilities",
                true
            )
        );
    }

    @Override
    public McpSchema.GetPromptResult generatePrompt(Map<String, String> arguments, Program program) {
        String functionIdentifier = arguments.get("function_name");

        if (functionIdentifier == null || functionIdentifier.isEmpty()) {
            return new McpSchema.GetPromptResult(
                "Error: function_name argument is required",
                List.of(new McpSchema.PromptMessage(
                    McpSchema.Role.USER,
                    new McpSchema.TextContent("Error: function_name argument is required")
                ))
            );
        }

        StringBuilder context = new StringBuilder();
        context.append("# Security Vulnerability Analysis Request\n\n");
        context.append("Please perform a security-focused analysis of the following function.\n\n");

        if (program != null) {
            Function function = findFunction(program, functionIdentifier);

            if (function != null) {
                context.append("## Function Information\n");
                context.append("- **Name**: ").append(function.getName()).append("\n");
                context.append("- **Address**: ").append(function.getEntryPoint()).append("\n");
                context.append("- **Signature**: ").append(function.getPrototypeString(false, false)).append("\n\n");

                // Get decompilation
                String decompiled = decompileFunction(program, function);
                if (decompiled != null) {
                    context.append("## Decompiled Code\n```c\n");
                    context.append(decompiled);
                    context.append("\n```\n\n");
                }

                // List dangerous functions called
                context.append("## Potentially Dangerous Functions Called\n");
                var calledFunctions = function.getCalledFunctions(TaskMonitor.DUMMY);
                boolean foundDangerous = false;
                for (Function called : calledFunctions) {
                    String name = called.getName().toLowerCase();
                    if (isDangerousFunction(name)) {
                        context.append("- **").append(called.getName()).append("** @ ").append(called.getEntryPoint()).append("\n");
                        foundDangerous = true;
                    }
                }
                if (!foundDangerous) {
                    context.append("No known dangerous functions detected.\n");
                }
                context.append("\n");

            } else {
                context.append("**Error**: Function '").append(functionIdentifier).append("' not found.\n\n");
            }
        } else {
            context.append("**Note**: No program loaded. Please provide function details manually.\n\n");
        }

        context.append("## Vulnerability Categories to Check\n");
        context.append("Please analyze for the following vulnerability types:\n\n");
        context.append("1. **Buffer Overflows**: Stack or heap buffer overflows, off-by-one errors\n");
        context.append("2. **Format String Bugs**: Improper use of printf-family functions\n");
        context.append("3. **Integer Overflows/Underflows**: Arithmetic issues leading to unexpected values\n");
        context.append("4. **Use After Free**: Accessing memory after deallocation\n");
        context.append("5. **Double Free**: Freeing memory multiple times\n");
        context.append("6. **Null Pointer Dereference**: Accessing null pointers\n");
        context.append("7. **Command Injection**: Unsafe execution of external commands\n");
        context.append("8. **Path Traversal**: Improper validation of file paths\n");
        context.append("9. **Information Disclosure**: Leaking sensitive data\n");
        context.append("10. **Race Conditions**: Time-of-check to time-of-use issues\n\n");

        context.append("## Output Format\n");
        context.append("For each potential vulnerability found, provide:\n");
        context.append("- **Type**: The category of vulnerability\n");
        context.append("- **Location**: Line or instruction address\n");
        context.append("- **Severity**: Critical/High/Medium/Low\n");
        context.append("- **Description**: Detailed explanation\n");
        context.append("- **Exploitation**: How it could be exploited\n");
        context.append("- **Mitigation**: Recommended fix\n");

        List<McpSchema.PromptMessage> messages = new ArrayList<>();
        messages.add(new McpSchema.PromptMessage(
            McpSchema.Role.USER,
            new McpSchema.TextContent(context.toString())
        ));

        return new McpSchema.GetPromptResult(
            "Identify vulnerabilities in: " + functionIdentifier,
            messages
        );
    }

    private boolean isDangerousFunction(String name) {
        String[] dangerous = {
            "strcpy", "strcat", "sprintf", "vsprintf", "gets", "scanf",
            "sscanf", "fscanf", "strncpy", "strncat", "memcpy", "memmove",
            "printf", "fprintf", "vprintf", "vfprintf", "syslog",
            "system", "popen", "execl", "execle", "execlp", "execv", "execve", "execvp",
            "alloca", "free", "realloc", "malloc"
        };

        for (String func : dangerous) {
            if (name.contains(func)) {
                return true;
            }
        }
        return false;
    }

    private Function findFunction(Program program, String identifier) {
        try {
            var addr = program.getAddressFactory().getAddress(identifier);
            if (addr != null) {
                return program.getFunctionManager().getFunctionAt(addr);
            }
        } catch (Exception e) {
            // Not an address
        }

        for (Function function : program.getFunctionManager().getFunctions(true)) {
            if (function.getName().equals(identifier)) {
                return function;
            }
        }
        return null;
    }

    private String decompileFunction(Program program, Function function) {
        DecompInterface decompiler = new DecompInterface();
        try {
            decompiler.openProgram(program);
            DecompileResults results = decompiler.decompileFunction(function, 30, TaskMonitor.DUMMY);
            if (results.decompileCompleted()) {
                return results.getDecompiledFunction().getC();
            }
        } finally {
            decompiler.dispose();
        }
        return null;
    }
}
